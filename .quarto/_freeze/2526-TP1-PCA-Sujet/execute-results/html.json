{
  "hash": "581660664663aa688a03334a35d598b2",
  "result": {
    "markdown": "---\ntitle: \"TP1 - Principal Component Analysis\"\nformat:\n  html:\n    toc: true\n    toc-depth : 4\n    toc-location: left\n    number-sections: true\n    css: styles.css\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(reshape2)\nlibrary(FactoMineR)\nlibrary(factoextra)\nlibrary(corrplot)\nlibrary(reticulate)\n```\n:::\n\n\n# Compréhension de l'ACP\n\n## Description des données\n\nDans cette première partie, nous considérons un jeu de données fictif pour décortiquer l'ACP. On considère les notes de 9 élèves dans 4 matières (Mathématiques, Physique, Français et Anglais).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n|         | Maths | Physique | Francais | Anglais |\n|:--------|:-----:|:--------:|:--------:|:-------:|\n|Olivier  |  6.0  |    6     |   5.0    |    5    |\n|Laura    |  8.0  |    8     |   8.0    |    8    |\n|Emma     |  6.0  |    7     |   11.0   |   10    |\n|Baptiste | 14.5  |    14    |   16.0   |   15    |\n|Aymeric  | 15.0  |    15    |   12.0   |   12    |\n|Mathilde | 10.0  |    10    |   5.5    |    7    |\n|Pauline  |  5.5  |    7     |   14.0   |   11    |\n|Maxime   | 13.0  |    12    |   8.5    |    9    |\n|Chloé    |  9.0  |    9     |   12.0   |   12    |\n:::\n:::\n\n\n**Question :** Représentez la distribution des notes par matière\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n**Question :** A l'aide de la fonction `corrplot()` de la librairie portant le même nom, représentez la matrice des corrélations de ce jeu de données\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n## ACP centrée\n\nComme les 4 variables sont à la même échelle, on décide de faire une analyse en composantes principales (ACP) sur les données centrées. A l'aide de la fonction `scale()`, centrez les données.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNoteC<-scale(...) # A COMPLETER\n```\n:::\n\n\n**Question :** Quelle matrice cherche-t-on à diagonaliser dans cette ACP ? Programmez cette matrice et diagonalisez-la à l'aide de la fonction `eigen()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGamma<- .... # A COMPLETER\nA<-eigen(...)  \n```\n:::\n\n\n**Question :** Que représentent les valeurs propres dans ce cas ? Que représente la somme de ces valeurs propres ? Vérifiez numériquement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n**Question :** Faites une ACP centrée à l'aide de la fonction `PCA` de la librairie `FactoMineR`. Retrouvez l'interprétation des valeurs propres et représentez-les à l'aide de la fonction `fviz_eig()` de la librairie `factoextra`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\nrespca<-PCA(...,graph=F)\nrespca$......\nfviz_eig(respca)\n```\n:::\n\n\n**Question :** Déterminez les axes principaux à partir des résultats de la diagonalisation. Comparez avec les résultats dans `respca`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n**Question :** Que contient la sortie `respca$ind$coord$` ? Comment obtient-on ses résultats à partir de la diagonalisation ? Vérifiez visuellement à l'aide de la commande `fviz_pca_ind(respca)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n## ACP centrée réduite\n\nOn fait maintenant une analyse en composantes principales sur les données centrées et réduites. Centrez et réduisez les données.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNotesCR<-....\n```\n:::\n\n\n**Question :** Quelle matrice cherche-t-on à diagonaliser dans ce cadre en ACP ? Programmez cette matrice et diagonalisez-la à l'aide de la fonction `eigen()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGamma2<- .... # A COMPLETER\nB<-eigen(...)  \n```\n:::\n\n\n**Question :** Que représentent les valeurs propres dans ce cas ? Que représente la somme de ces valeurs propres ? Vérifiez numériquement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n**Question :** Faites une ACP centrée réduite à l'aide de la fonction `PCA` de la librairie `FactoMineR`. Retrouvez l'interprétation des valeurs propres et représentez-les à l'aide de la fonction `fviz_eig()` de la librairie `factoextra`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\nrespca2<-PCA(...,graph=F)\nfviz_eig(respca2)\n```\n:::\n\n\n**Question :** Que représente la sortie suivante ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_pca_var(respca2)\n```\n:::\n\n\n**Question :** Représentez les projetés des individus dans le premier plan factoriel et commentez.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n**Question :** Comment peut-on obtenir les résultats de cette ACP centrée réduite à partir du tableau de données centrées. Vérifiez numériquement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n# Données Ozone\n\n## Description des données\n\nLes données étudiées ont été recueillies à Rennes dans $112$ stations durant l'été 2001. Les 12 variables observées sont :\n\n-   maxO3 : Maximum de concentration d'ozone observé sur la journée en $\\mu$gr/m3\n-   T9, T12, T15 : Température observée à 9, 12 et 15h\n-   Ne9, Ne12, Ne15 : Nébulosité observée à 9, 12 et 15h\n-   Vx9, Vx12, Vx15 : Composante E-O du vent à 9, 12 et 15h\n-   vent : orientation du vent à 12h\n-   pluie : occurrence ou non de précipitations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nOzone<-read.table(\"Ozone.txt\",header=T)\nOzone$pluie<-as.factor(Ozone$pluie)\nOzone$vent<-as.factor(Ozone$vent)\nOzone<-Ozone[,-11]\nsummary(Ozone)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     maxO3              T9             T12             T15       \n Min.   : 42.00   Min.   :11.30   Min.   :14.00   Min.   :14.90  \n 1st Qu.: 70.75   1st Qu.:16.20   1st Qu.:18.60   1st Qu.:19.27  \n Median : 81.50   Median :17.80   Median :20.55   Median :22.05  \n Mean   : 90.30   Mean   :18.36   Mean   :21.53   Mean   :22.63  \n 3rd Qu.:106.00   3rd Qu.:19.93   3rd Qu.:23.55   3rd Qu.:25.40  \n Max.   :166.00   Max.   :27.00   Max.   :33.50   Max.   :35.50  \n      Ne9             Ne12            Ne15           Vx9         \n Min.   :0.000   Min.   :0.000   Min.   :0.00   Min.   :-7.8785  \n 1st Qu.:3.000   1st Qu.:4.000   1st Qu.:3.00   1st Qu.:-3.2765  \n Median :6.000   Median :5.000   Median :5.00   Median :-0.8660  \n Mean   :4.929   Mean   :5.018   Mean   :4.83   Mean   :-1.2143  \n 3rd Qu.:7.000   3rd Qu.:7.000   3rd Qu.:7.00   3rd Qu.: 0.6946  \n Max.   :8.000   Max.   :8.000   Max.   :8.00   Max.   : 5.1962  \n      Vx12             Vx15           vent      pluie   \n Min.   :-7.878   Min.   :-9.000   Est  :10   Pluie:43  \n 1st Qu.:-3.565   1st Qu.:-3.939   Nord :31   Sec  :69  \n Median :-1.879   Median :-1.550   Ouest:50             \n Mean   :-1.611   Mean   :-1.691   Sud  :21             \n 3rd Qu.: 0.000   3rd Qu.: 0.000                        \n Max.   : 6.578   Max.   : 5.000                        \n```\n:::\n:::\n\n\n**Question :** Faites quelques statistiques descriptives pour appréhender le jeu de données. En particulier, étudiez les corrélations entre les variables quantitatives.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n## ACP avec FactoMineR\n\n**Question :** Mettez en place une analyse en composantes principales à l'aide de la librairie `FactoMineR`. Combien de composantes principales retenez-vous ? Comment interprétez-vous les composantes principales en fonction des variables initiales ? Commentez la projection des individus dans les plans factoriels ? Vous pouvez compléter votre analyse à l'aide des variables qualitatives Pluie et Vent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A COMPLETER\n```\n:::\n\n\n## ACP en Python\n\nOn s'intéresse maintenant à faire une analyse en composante principale sous Python. A l'aide des commandes suivantes, mettez en place une telle analyse. N'hésitez pas à améliorer la programmation en Python !\n\n### Avec le package [Prince](https://maxhalford.github.io/prince/)\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\nOzonepy=pd.read_csv('Ozone.txt',sep=\" \",header=0).set_index([\"pluie\",\"vent\"])\nOzonepy=Ozonepy.iloc[:,:10]\nOzonepy\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport prince\n\npca = prince.PCA(\n    n_components=5,\n    n_iter=3,\n    rescale_with_mean=True,\n    rescale_with_std=True,\n    copy=True,\n    check_input=True,\n    engine='sklearn',\n    random_state=42\n)\n\npca = pca.fit(Ozonepy)\npca.eigenvalues_summary\n    #pca.eigenvalues_\n    #pca.percentage_of_variance_\n    #pca.cumulative_percentage_of_variance_\n    \npca.scree_plot()    \n```\n:::\n\n\nProjection des individus :\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Coordonnées - Composantes principales\npca.transform(Ozonepy).head()\n\n# Visualisation\n\npca.plot(\n     Ozonepy,\n    x_component=0,\n    y_component=1,\n    color_rows_by='pluie',\n    show_row_markers=True,\n    show_column_markers=False,\n    show_row_labels=False,\n    row_labels_column=None,  # for DataFrames with a MultiIndex\n    show_column_labels=False\n)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npca.plot(\n     Ozonepy,\n    x_component=0,\n    y_component=1,\n    color_rows_by='vent',\n    show_row_markers=True,\n    show_column_markers=False,\n    show_row_labels=False,\n    row_labels_column=None,  # for DataFrames with a MultiIndex\n    show_column_labels=False\n)\n```\n:::\n\n\nLes axes principaux :\n\n\n::: {.cell}\n\n```{.python .cell-code}\npca.column_coordinates_\n```\n:::\n\n\nContribution des individus :\n\n\n::: {.cell}\n\n```{.python .cell-code}\npca.row_contributions_.head().style.format(precision=2)  \n```\n:::\n\n\nContributions des variables :\n\n\n::: {.cell}\n\n```{.python .cell-code}\npca.column_contributions_.style.format(precision=2)\n```\n:::\n\n\nCorrélation des variables :\n\n\n::: {.cell}\n\n```{.python .cell-code}\npca.column_correlations.style.format(precision=2)\n```\n:::\n\n\n### Avec scikit-learn\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\n\nOzonepy=pd.read_csv('Ozone.txt',sep=\" \",header=0)\nOzoneSC=Ozonepy.iloc[:,:10]\nOzoneSC= StandardScaler().fit_transform(OzoneSC)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom sklearn.decomposition import PCA\npca=PCA(n_components=3)\ndataPCA=pca.fit_transform(OzoneSC)\npca.explained_variance_ratio_\nprint(pca.explained_variance_ratio_.cumsum()) \n\n\nprincipalDf=pd.DataFrame(data=dataPCA,columns=['PC 1', 'PC 2','PC 3'])\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport matplotlib.pyplot as plt\nimport plotly.express as px\n\n#pca_df = pd.DataFrame({\n#    \"Dim1\" : dataPCA[:,0], \n#    \"Dim2\" : dataPCA[:,1],\n#    \"Pluie\" :Ozonepy.pluie,\n#    \"Vent\" : Ozonepy.vent\n#})\n#fig=px.scatter(pca_df,x=\"Dim1\", y=\"Dim2\", color=\"Vent\")\n#fig.show()\n#fig=px.scatter(pca_df,x=\"Dim1\", y=\"Dim2\", color=\"Pluie\")\n#fig.show()\n\nfig=px.scatter(dataPCA,x=0,y=1,color=Ozonepy.pluie)\nfig.show()\n\nfig=px.scatter(dataPCA,x=0,y=1,color=Ozonepy.vent)\nfig.show()\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nloadings = pca.components_.T * np.sqrt(pca.explained_variance_)\n#features = ['max03', 'T9', 'T12', 'T15','\"Ne9','Ne12','Ne15','Vx9','Vx12','Vx15']\nfeatures=Ozonepy.iloc[:,:10].columns.values\n\nfor i, feature in enumerate(features):\n    fig.add_annotation(\n        ax=0, ay=0,\n        axref=\"x\", ayref=\"y\",\n        x=loadings[i, 0],\n        y=loadings[i, 1],\n        showarrow=True,\n        arrowsize=2,\n        arrowhead=2,\n        xanchor=\"right\",\n        yanchor=\"top\"\n    )\n    fig.add_annotation(\n        x=loadings[i, 0],\n        y=loadings[i, 1],\n        ax=0, ay=0,\n        xanchor=\"center\",\n        yanchor=\"bottom\",\n        text=feature,\n        yshift=5,\n    )\n#fig.show()\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# cercle des correlation\n\n(fig, ax) = plt.subplots(figsize=(8, 8))\nfor i in range(0, pca.components_.shape[1]):\n    ax.arrow(0,\n             0,  # Start the arrow at the origin\n             loadings[i, 0],  #0 for PC1\n             loadings[i,1],  #1 for PC2\n             head_width=0.1,\n             head_length=0.1)\n\n    plt.text(loadings[i,0] + 0.05,\n             loadings[i,1] + 0.05,\n             features[i])\n\n\nan = np.linspace(0, 2 * np.pi, 100)\nplt.plot(np.cos(an), np.sin(an))  # Add a unit circle for scale\nplt.axis('equal')\nax.set_title('Variable factor map')\nplt.show()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}